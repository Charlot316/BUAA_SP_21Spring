# 第十五周 实验指南：线程

[TOC]

## 一、实验目的

1. 掌握与线程相关的概念。
2. 掌握创建线程、挂起线程等线程相关操作。
3. 掌握线程同步的方法。

## 二、实验指南

### 线程简介

#### 线程介绍

每个线程（thread）是 CPU 使用的一个基本单元；它包括线程 ID、程序计数器、寄存器组和堆栈。它与同一进程的其他线程共享代码段、数据段和其他操作系统资源，如打开文件和信号。如果一个进程具有多个控制线程，那么它能同时执行多个任务。从这个角度来看，线程就是一个进程的执行进度。一个进程可能需要同时执行多个任务，比如一个浏览器进程，一方面要渲染页面呈现给用户，另一方面，同时还要处理网络请求，从网络中接收和发送数据。

下图生动的说明了进程和线程的关系：

<img src="http://cdn.loheagn.com/2020-05-28-115611.png" alt="image-20200526114712359" style="zoom:50%;" />

##### 使用线程的动机

**正如前面所述**，**一个应用程序通常作为具有多个控制线程的一个进程来实现**。例如，一个 Web 浏览器可能有一个线程来显示图像和文本，另一个线程从网络接收数据。一个字处理器（比如 Word）可能有一个线程显示文字在屏幕上，另一个线程用于相应用户键盘的输入，还有一个线程在后台进行拼写和语法的检查。应用程序也可以设计成利用多核系统的能力。这些应用程序可以在一个 CPU 的多个核心上**并行**执行多个 CPU 密集型的任务。

还有一种情况，就是**一个应用程序可能需要同时执行多个相似任务**。比如大家在软工课上学到的后端的网络编程，就是开一个服务器，接收前端传过来的`request`，然后作出处理后返回`response`。在实际使用中，这个服务器肯定会**几乎同时**接收多个（甚至是数千个）来自前端的请求。如果服务器只有一个进程的话，这些请求会被放到一个队列里，挨个处理并返回数据。那前端的用户肯定要忍受很长时间的等待。所以，现代服务器的通用做法是，每接收一个前端传过来的请求，就分配（可能是创建、也有可能是复用之前的线程）一个线程用于处理该请求。从这里也可以看到，由于对于每个请求的处理逻辑都是完全相同的（很显然），所以每个线程都是使用的同一份代码，也就是说，同一个进程中，各个线程之间的代码是共享的。

**实际上，上述的两种情况完全可以只使用进程，而不使用线程来解决。**比如，谁规定一个浏览器只能有一个进程，我完全可以开多个进程来**并发**处理啊；谁规定一个服务器只能有一个进程，我完全可以每接收一个前端请求就创建一个新的进程来处理啊，不就是使用同一段代码吗，我用`fork`和`exec`族函数完全可以解决啊（实际上，早期的 cgi 技术就是这样做的）。实际上，早期的 Linux 系统中也的确没有线程这个概念。

**我们在上述场景中更倾向于使用线程而不是进程，是基于以下几个线程的优点。**

##### 使用线程的好处

- **响应性**。试想，如果浏览器是一个只有一个线程的进程。如果此时网络发生了延迟，请求网络数据的操作处于等待状态，那整个浏览器的所有操作都将停滞（因为只有一个线程嘛），此时你点击任何位置的按钮或图片都将得不到相应，这无疑是一个非常糟糕的体验。
- **资源共享**。进程只能通过共享内存和消息传递之类的技术（消息队列、管道等）共享资源。而同一个进程的线程之间天然可以共享同一个虚拟地址空间的代码、数据、全局变量等等，这相比于进程来说，更加高效和限制更小。比如，进程之间数据的共享要通过内核来进行，用户地址空间的代码访问一次内核空间（系统调用）的代价是很大的；而且共享的数据大小还要受到内核地址空间大小的限制，非常不方便。
- **经济**。进程创建所需的内存和资源分配非常昂贵。由于线程能够共享它们所属进程的资源，所以创建和切换线程更加经济。虽然进程创建和管理与线程创建和管理的开销差异的实际测量较为困难，但是前者通常比后者花费更多时间。在某些系统中，进程创建比线程创建慢 30 倍，而且进程切换要比线程切换慢 5 倍。
- **可伸缩性**。对于多处理器体系结构，多线程的优点更大，因为线程可在多处理核上**并行**运行。不管有多少可用 CPU，单线程进程只能运行在一个 CPU 上。对这部分内容感兴趣的同学可以阅读这篇文章：[利用多核多线程进行程序优化](https://www.ibm.com/developerworks/cn/linux/l-cn-optimization/index.html)。

##### 并发与并行

大家可能注意到了上文中的“并发”和“并行”都被高亮了，就是为了提醒大家，**并发（concurrent）和并行（parallel）虽然看起来很相近，但这是两个不同的概念**（又是翻译的锅）。这里的 parallel 本身还有“平行”的意思，可以从这个词的含义中大致理解“并行”想表达的含义。大家可以先看看下面这张图感受一下：

<img src="http://cdn.loheagn.com/2020-05-28-115622.png" alt="image-20200526214913966" style="zoom: 67%;" />

**并发的意思是多个任务被交替执行**，只不过切换的过程很快，**让人以为它们是在同时执行**。

**并行的意思是多个任务确确实实在同时执行，**这种情况出现在多核系统上。所谓“多核”，意思就是具有多个处理器核心的计算机系统，基本上大家现在用的计算机都是这种。

因此，如果没有线程，只有进程的话（也就是只包含一个线程的进程），那么该进程只能**并发**执行，也就是说，该进程在某一时刻，只能使用一个 CPU 核心执行任务，即使你有多个处理器核心，其他几个核心也是闲置的（起码不能被当前这个进程使用）。而如果该进程有多个线程，那么就可以把这多个线程比较平均的分配到多个 CPU 核心上去**并行**执行，从而使得多核计算机的性能被充分利用（比如，你打文明的时候是不是经常看着它空置多个核心而干瞪眼？）。当然，如何合理分配线程来并行执行是一个非常困难和有挑战的事情，不然也不会有很多 3A 大作到现在还是单核游戏了。

##### 线程是最小的调度单位，进程是最小的资源分配单位

还是回到开头那幅图：

<img src="http://cdn.loheagn.com/2020-05-28-115628.png" alt="image-20200526114712359" style="zoom: 50%;" />

在这幅图中，我们可以看到，一个线程有自己的寄存器和堆栈，这是程序执行最基本的要素。也就是说，线程本身就是程序执行的最基本的单位，或者说，**线程本身就是一个进程的执行部分**。所谓 CPU 调度的本质就是选择合适的线程放到一个 CPU 核心上来执行。因此，在每个 CPU 核心上执行的是一个个线程，而不是进程本身（不区分线程的进程也可以看做是只有一个线程的进程）。所以，我们看到的 CPU 的宣传都是什么 6 核心 12 线程（超线程技术）、64 核心 128 线程、线程撕裂者之类的，而没有什么“进程撕裂者”、“6 核心 12 进程”之类的说法。

同一个进程的线程之间又使用相同的**IO 资源、信号、内存资源**等，这些资源都是以操作系统以进程为单位分配的。于是，进程被称为是“资源分配的最小单位”。

### 线程操作（Pthreads）

本节内容介绍的是 POSIX 中描述的线程操作的标准。POSIX 是由 IEEE 指定的一系列标准，全称是**可移植操作系统接口**（Portable Operating System Interface）。从名字上可以看出，POSIX 的理想是，提供这样一套标准，以使得使用这套标准的 API 编写的代码，可以在不怎么修改的情况下，移植到任意一个实现了这套标准的操作系统上。请注意，POSIX 本身只是对 API 的描述，操作系统如果想要兼容 POSIX 标准，就需要去实现这些 API。一般的 Unix 系统和类 Unix 系统都会去实现 POSIX 标准。（虽然严格意义上来讲，Linux 系统从来没有被官方认证为 POSIX，但不妨碍我们在事实上把它作为一个 POSIX 兼容的系统来使用）。

Pthreads 就是 POSIX 标准定义的线程创建与同步的 API。许多操作系统都实现了这个线程规范，其中就包括 macOS、Solaris 等（所以，这次实验的一些代码可以在 macOS 上尝试）。Linux 也通过一些内核外的库实现了 POSIX 标准。

下面列出了几个大家需要掌握的几个函数的用法（理解即可，如果考试需要的话，会给出如下所示的函数签名），具体的用法和使用场景在《Linux 编程基础》中已经讲的比较详细了，这里就不再赘述。

**编译使用了`pthread.h`的头文件的代码的时候，一定加上`-lpthread`参数。比如`gcc -lpthread example.c -o example`。**

#### 创建线程

```c
// pthread.h

int pthread_create(pthread_t _Nullable * _Nonnull __restrict,
    const pthread_attr_t * _Nullable __restrict,
    void * _Nullable (* _Nonnull)(void * _Nullable),
    void * _Nullable __restrict);
```

- 第一个参数为指向线程标识符的指针，当`pthread_create`成功返回时，新创建线程的线程 ID 会被设置成`tidp`指向的内存单元，并可以通过接口函数`pthread_self`获取;

- 第二个参数用来设置线程属性，通常传入 NULL，表示线程的默认属性;

- 第三个参数是线程运行函数的起始地址;

- 最后一个参数是运行函数的参数。

#### 线程退出

```c
//  pthread.h

// 这个函数是自己干掉自己
void pthread_exit(void *ral_ptr);
```

#### 线程取消

```c
// pthread.h

// 这个函数是自己干掉另一个线程
int pthread_cancel(pthread_t tid);
```

#### 线程挂起

```c
// pthread.h

int pthread_join(pthread_t thread, void **rval_ptr);
```

#### 线程分离

```c
// pthread.h

int pthread_detach(pthread_t tid);
```

#### Java 中的线程

Java 的多线程编程很重要，大家一定要认真掌握。

大家在 OOP 上应该都学过了，Java 的执行过程是这样的：Java 源代码首先被编译成`.class`字节码文件，然后这些字节码文件被加载到 Java 虚拟机中运行。在执行过程中，Java 虚拟机可以看做是一个进程，大家在 Java 中创建的线程都是针对于“Java 虚拟机”这个进程来说的。Java 虚拟机在实现的时候，会把用户创建的线程映射到操作系统的线程模型中。例如，在 Linux 中，Java 虚拟机会把用户创建的每一条线程映射到一个轻量级进程。

### 线程同步

#### 线程需要同步的原因

因为一个进程中的多个线程是共享资源的，也就是说，进程的全局变量等每个线程都可以访问都。而每个线程都是由一个调度器调度的，一般情况下，我们很难判定一个线程什么时候执行、什么时候阻塞、什么时候退出，这就是多线程编程的**不确定性**。因此，在多线程编程的情况下，当一个线程使用公共资源（比如修改全局变量）的时候，不可能确定说这个变量在我使用的过程中不被其他线程修改，或者我的使用和修改不会对其他线程造成影响。因此，有必要对线程进行同步。

关于这部分的内容，希望大家结合着 Java 的多线程编程来理解和学习。两者相辅相成，大有裨益。

#### 临界区

所谓临界区，就是代码中涉及对公共资源修改的那部分代码。我们看一个《Linux 编程基础》中的例子。

<img src="http://cdn.loheagn.com/2020-05-28-172939.png" alt="image-20200529012930975" style="zoom:50%;" />

上图中用红框框起来的那部分就是临界区。大家可能会有疑惑：诶，没看见修改啥公共资源啊。请注意其中的`printf`，这个函数是要向 screen 中输出字符，很显然，这里的“screen”是各个线程公有的，所以是公共资源。

#### 互斥锁

互斥锁的原理很简单，就是在线程要执行临界区的代码之前加锁，出临界区后释放锁。

这就好比一个只能一个人用的屋子（**临界区**），你只想在里面自己做些私密的事情，就可以在进入屋子前检查门是不是被锁了，如果没被锁，说明此时没人占用，你的使用是绝对安全的，就可以进入并**上锁**；此时，如果其他人要进入，看到门锁了，就要在外面**等待**，直到你**开锁**出门为止；相反，如果你进入之前门被锁了，说明有其他人在使用，那你也要**等待**，直到锁被打开。这里可能出现一种情况，就是很多人都想进去，但都被挡在门外面了，那么，等到锁被打开时，就要**竞争**进入屋子里，也就是一堆人去抢那把锁，能抢到的人就获得了进入的资格，其他的倒霉孩子则要接着等待。

相信大家从这个例子中就能学会互斥锁的使用原理了。

例如，上面临界区的例子中，如果用互斥锁实现对 screen 的同步使用，那么应该是下面这个样子：

<img src="http://cdn.loheagn.com/2020-05-29-043407.png" alt="image-20200529123353252" style="zoom:50%;" />

#### 条件变量

现在设想这样一种情况，当你需要进入这个只能被一个人独享的房间做事情时，在成功**获得锁**进入屋子（**进入临界区**）后，发现屋子里有个告示，给出了继续占有这间屋子的**条件**，说明只有学会了时间管理的人才能使用屋子中资源，你自己**判断**了一下，发现自己不符合条件，于是只能选择放弃使用临界区的资源**，而去学习时间管理。但总不能屋子空着让你白占着啊，所以此时你还要主动**释放锁**，然后才能去**等待**（注意，这里的“等待”不是等待锁，而是等待自己学会时间管理，在你**被唤醒之前**，没有资格参与对锁的竞争）。等你学会了时间管理，**满足了条件，被**通知唤醒**，就可以重新加入到抢占锁的队伍中，重新参与竞争了。

总结一下，这里的进入屋子的“条件”，就是条件变量。《Linux 编程基础》给出的这个图说明的很详细：

\*\*\*\*![image-20200529015832290](http://cdn.loheagn.com/2020-05-28-175839.png)

有一点要特别注意的是，在被条件变量唤醒、重新获得锁进入后，需要**再次判断**是不是符合条件。这是因为“被唤醒”和“重新获得锁”之间不是原子操作，无法保证该线程的状态不会再次发生变化使其不满足条件。

#### 信号量

信号量部分的原理可以参照上次实验。本部分内容详见《Linux 编程基础》一书。

## 三、实验习题

1. 创建一个线程，分别打印该线程和原来的线程的进程号和父进程号，然后回收刚刚创建的线程。**给出代码和操作步骤。**

2. 仅使用锁来实现两个线程的同步，让线程 a 不断地为公共变量 Num 增加 1，而当 Num 增加至 100 时线程 b 将 Num 归 0，不断重复上述过程。**将 Num 输出到屏幕并给出代码和操作步骤。**

3. 在实际过程中，条件变量和互斥锁总是结合使用，因为互斥锁只能表示锁与不锁两种状态，而仅靠条件变量本身也是无法实现线程同步的。条件变量允许线程以无竞争的方式进行等待直到某条件发生，而不是总是尝试去获取锁。使用条件变量和锁重写上一问题，**给出代码和操作步骤**。

4. 在一个程序中创建 8 个线程，每个线程打印你的学号中的一位数字，按照学号顺序打印出来。**不要使用`sleep`来进行同步，给出代码和操作步骤**。本题目你采取的同步策略是什么，为什么采用这样的策略，这是最好的同步策略吗？

5. 生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。

   生产者消费者问题主要要注意以下三点：

   - 在缓冲区为空时，消费者不能再进行消费

   - 在缓冲区为满时，生产者不能再进行生产

   - 在一个线程进行生产或消费时，其余线程不能再进行生产或消费等操作，即保持线程间的同步

     现在假设缓冲区上限为 20，生产者和消费者线程各 10 个，请编写程序实现一个生产者消费者模型。**在每次生产、消费时将当前动作类型（produce/consume）与缓冲区内容量输出到屏幕，给出代码和操作步骤。**
