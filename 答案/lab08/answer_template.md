# Lab08 Assignment

> 班级：
> 学号：
> 姓名：

## 1. 创建一个线程，分别打印该线程和原来的线程的进程号和父进程号，然后回收刚刚创建的线程

```c
//code

```

截图：

## 2. 仅使用锁来实现两个线程的同步，让线程 a 不断地为公共变量 Num 增加 1，而当 Num 增加至 100 时线程 b 将 Num 归 0，不断重复上述过程。**将 Num 输出到屏幕并给出代码和操作步骤。**

```c
//code

```

截图：

## 3. 在实际过程中，条件变量和互斥锁总是结合使用，因为互斥锁只能表示锁与不锁两种状态，而仅靠条件变量本身也是无法实现线程同步的。条件变量允许线程以无竞争的方式进行等待直到某条件发生，而不是总是尝试去获取锁。使用条件变量和锁重写上一问题，**给出代码和操作步骤**

```c
//code

```

截图：

## 4. 在一个程序中创建 8 个线程，每个线程打印你的学号中的一位数字，按照学号顺序打印出来。**不要使用`sleep`来进行同步，给出代码和操作步骤**

```c
//code

```

截图：

**本题目你采取的同步策略是什么，为什么采用这样的策略，这是最好的同步策略吗？**

```
//ans

```

## 5. 假设缓冲区上限为 20，生产者和消费者线程各 10 个，请编写程序实现一个生产者消费者模型。**在每次生产、消费时将当前动作类型（produce/consume）与缓冲区内容量输出到屏幕，给出代码和操作步骤。**

生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。

生产者消费者问题主要要注意以下三点：

- 在缓冲区为空时，消费者不能再进行消费
- 在缓冲区为满时，生产者不能再进行生产
- 在一个线程进行生产或消费时，其余线程不能再进行生产或消费等操作，即保持线程间的同步

```c
//code

```

截图：
